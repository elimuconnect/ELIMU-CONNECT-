<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Shorts Combiner — Merge many short videos into one MP4</title>

  <style>
    :root{
      --bg:#0f1724; --card:#0b1220; --accent:#1976d2; --muted:#9aa7bd;
      --glass: rgba(255,255,255,0.03);
    }
    html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Arial;background:linear-gradient(180deg,#071024 0%, #081428 100%);color:#e6eef8}
    .wrap{max-width:980px;margin:20px auto;padding:20px;border-radius:12px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));box-shadow:0 10px 30px rgba(2,6,23,0.6);}
    h1{margin:0 0 8px;font-size:20px}
    p.lead{margin:0 0 16px;color:var(--muted)}
    .controls{display:flex;gap:10px;flex-wrap:wrap;align-items:center;margin-bottom:12px}
    .file-select{background:var(--glass);padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.03)}
    .files{margin:12px 0;display:grid;grid-template-columns:1fr;gap:8px;max-height:240px;overflow:auto;padding:6px}
    .file-item{display:flex;align-items:center;gap:10px;padding:8px;border-radius:8px;background:linear-gradient(90deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));border:1px solid rgba(255,255,255,0.02)}
    .file-item strong{width:36px;display:inline-block}
    .muted{color:var(--muted)}
    button{background:var(--accent);border:none;color:white;padding:10px 14px;border-radius:10px;font-weight:600;cursor:pointer;box-shadow:0 6px 18px rgba(25,118,210,0.12)}
    button.alt{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted)}
    #log{height:220px;overflow:auto;background:#071022;border-radius:8px;padding:10px;font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", monospace;font-size:13px;color:#bfefff;border:1px solid rgba(255,255,255,0.03)}
    .row{display:flex;gap:10px;align-items:center}
    input[type="file"]{color:transparent;padding:6px 0}
    a#downloadLink{display:inline-block;padding:10px 12px;border-radius:10px;background:linear-gradient(90deg,#00b894,#0984e3);color:#fff;font-weight:700;text-decoration:none}
    footer{margin-top:14px;color:var(--muted);font-size:13px}
    .progressBar{height:10px;background:rgba(255,255,255,0.04);border-radius:999px;overflow:hidden}
    .progressBar > i{display:block;height:100%;width:0;background:linear-gradient(90deg,#06b6d4,#2563eb)}
    .danger{color:#ff8a80}
    .small{font-size:13px;color:var(--muted)}
    @media (max-width:600px){ .controls{flex-direction:column;align-items:stretch} }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Shorts Combiner — Merge many short videos into one MP4</h1>
    <p class="lead">Select multiple short MP4/WebM files (9:16). This page will re-encode each clip to H.264/AAC and concatenate them into one MP4 suitable for YouTube/TikTok. Recommended: test with a few files first.</p>

    <div class="controls">
      <label class="file-select">
        <span class="small muted">Select videos (multiple)</span><br>
        <input id="fileInput" type="file" accept="video/*" multiple>
      </label>

      <div class="row">
        <button id="btnReorder" class="alt">Shuffle order</button>
        <button id="btnCombine">Combine (start)</button>
        <a id="downloadLink" class="hidden" style="display:none;margin-left:6px"></a>
      </div>
    </div>

    <div class="files" id="filesList"></div>

    <div style="display:flex;gap:12px;align-items:center;margin-top:8px">
      <div style="flex:1">
        <div class="small">FFmpeg status:</div>
        <div class="progressBar" style="margin-top:6px"><i id="loadProgress"></i></div>
      </div>
      <div style="width:200px;text-align:right" id="ffStatus">idle</div>
    </div>

    <h3 style="margin-top:14px">Progress & Log</h3>
    <div id="log">Logs will appear here.</div>

    <footer>
      <div class="small">Note: the tool loads FFmpeg WASM from a CDN at runtime. If you see errors about Worker/core loading, open in a Chrome/Edge browser and try again. For truly offline use (single-file with embedded wasm) contact me — it’s possible but very large.</div>
    </footer>
  </div>

  <script type="module">
    // Use a stable ESM build hosted on jsDelivr that supports module import
    // If this import fails, try a different modern Chromium browser (Chrome/Edge recommended).
    import { createFFmpeg, fetchFile } from 'https://cdn.jsdelivr.net/npm/@ffmpeg/ffmpeg@0.11.7/dist/ffmpeg.min.mjs';

    const ffmpeg = createFFmpeg({
      log: true,
      corePath: 'https://cdn.jsdelivr.net/npm/@ffmpeg/core@0.11.1/dist/ffmpeg-core.js'
    });

    const fileInput = document.getElementById('fileInput');
    const filesList = document.getElementById('filesList');
    const btnCombine = document.getElementById('btnCombine');
    const btnReorder = document.getElementById('btnReorder');
    const logEl = document.getElementById('log');
    const downloadLink = document.getElementById('downloadLink');
    const loadProgressEl = document.getElementById('loadProgress');
    const ffStatusEl = document.getElementById('ffStatus');

    let files = []; // File objects

    function appendLog(msg, isErr) {
      const when = new Date().toISOString().slice(11,19);
      logEl.textContent += `[${when}] ${msg}\n`;
      logEl.scrollTop = logEl.scrollHeight;
      if (isErr) console.error(msg);
    }

    fileInput.addEventListener('change', e => {
      files = Array.from(e.target.files).filter(f => f.size > 0);
      renderFiles();
      appendLog(`Selected ${files.length} file(s).`);
    });

    function renderFiles(){
      filesList.innerHTML = '';
      if(files.length === 0){
        filesList.innerHTML = '<div class="small muted">No files selected</div>';
        return;
      }
      files.forEach((f,i) => {
        const div = document.createElement('div');
        div.className = 'file-item';
        const name = document.createElement('div');
        name.style.flex = '1';
        name.style.overflow = 'hidden';
        name.style.textOverflow = 'ellipsis';
        name.style.whiteSpace = 'nowrap';
        name.textContent = f.name;
        div.innerHTML = `<strong>#${i+1}</strong>`;
        div.appendChild(name);
        const size = document.createElement('small');
        size.className = 'muted';
        size.textContent = `${(f.size/1024/1024).toFixed(2)} MB`;
        div.appendChild(size);
        filesList.appendChild(div);
      });
    }

    btnReorder.addEventListener('click', ()=>{
      if(!files.length){ appendLog('No files to shuffle'); return; }
      // Fisher-Yates shuffle
      for(let i = files.length - 1; i > 0; i--){
        const j = Math.floor(Math.random()*(i+1));
        [files[i], files[j]] = [files[j], files[i]];
      }
      appendLog('Shuffled order');
      renderFiles();
    });

    // Hook FFmpeg logging to progress bar and log
    let lastLog = '';
    const onFFmpegLog = ({ type, message }) => {
      // message contains ffmpeg console output
      appendLog(message);
      lastLog = message;
      // try to extract a percent marker
      const m = message.match(/time=\s*([0-9:.]+)/i);
      if (m){
        // not using percent reliably; ignore
      }
    };

    async function ensureFFmpegLoaded(){
      if (ffmpeg.isLoaded()) return;
      ffStatusEl.textContent = 'loading ffmpeg...';
      appendLog('Loading ffmpeg.wasm (this may take several seconds) ...');
      // hook progress by polling bytesLoaded (not always available). We'll show spinner-like progress.
      try{
        // attach writer to console logs
        ffmpeg.setLogger(onFFmpegLog);
        await ffmpeg.load();
        ffStatusEl.textContent = 'ffmpeg loaded';
        appendLog('FFmpeg loaded successfully.');
        loadProgressEl.style.width = '100%';
      }catch(err){
        appendLog('Failed to load ffmpeg: ' + (err.message || err), true);
        ffStatusEl.textContent = 'ffmpeg load error';
        throw err;
      }
    }

    btnCombine.addEventListener('click', async ()=>{
      if(!files.length){ appendLog('Please select video files first'); return; }

      // safety check
      if(files.length > 200 && !confirm('You selected more than 200 files — this may crash the browser. Continue?')) return;

      try{
        await ensureFFmpegLoaded();
      }catch(e){
        appendLog('Cannot continue without ffmpeg.', true);
        return;
      }

      downloadLink.style.display = 'none';
      downloadLink.classList.add('hidden');

      appendLog(`Preparing ${files.length} files for re-encoding...`);
      ffStatusEl.textContent = 'processing';

      try{
        const tsNames = [];
        // write & re-encode each file into MPEG-TS segments (robust concat)
        for(let i=0;i<files.length;i++){
          const f = files[i];
          const inName = `in_${i}${getExt(f.name)}`;
          appendLog(`Writing ${f.name} -> ${inName}`);
          ffmpeg.FS('writeFile', inName, await fetchFile(f));

          const tsName = `seg_${('000'+i).slice(-4)}.ts`;
          appendLog(`Re-encoding ${inName} -> ${tsName} (H.264/AAC, 1080x1920 pad)`);
          // run ffmpeg: scale to 1080x1920 with padding to preserve aspect ratio
          await ffmpeg.run(
            '-y',
            '-i', inName,
            '-c:v', 'libx264', '-preset', 'veryfast', '-crf', '23',
            '-c:a', 'aac', '-b:a', '128k',
            '-vf', 'scale=1080:1920:force_original_aspect_ratio=decrease,pad=1080:1920:(ow-iw)/2:(oh-ih)/2',
            '-movflags', 'faststart',
            '-f', 'mpegts',
            tsName
          );

          tsNames.push(tsName);

          // free input file from virtual FS
          try{ ffmpeg.FS('unlink', inName); }catch(e){}
          appendLog(`Done ${i+1}/${files.length}`);
        }

        appendLog('Creating concat list...');
        const listTxt = tsNames.map(n => `file '${n}'`).join('\n');
        ffmpeg.FS('writeFile', 'list.txt', listTxt);

        appendLog('Concatenating segments into final MP4 (this may take time)...');
        // concat using mpegts copy -> output.mp4
        await ffmpeg.run('-y', '-f', 'concat', '-safe', '0', '-i', 'list.txt', '-c', 'copy', 'output.mp4');

        appendLog('Reading output.mp4 from virtual FS...');
        const data = ffmpeg.FS('readFile', 'output.mp4');
        const blob = new Blob([data.buffer], { type: 'video/mp4' });
        const url = URL.createObjectURL(blob);

        downloadLink.href = url;
        downloadLink.download = `combined_${Date.now()}.mp4`;
        downloadLink.textContent = '⬇️ Download combined MP4';
        downloadLink.style.display = 'inline-block';
        downloadLink.classList.remove('hidden');

        appendLog('Combined video ready — click the download link.');
        ffStatusEl.textContent = 'done';

        // cleanup temporary files
        for(const n of tsNames){ try{ ffmpeg.FS('unlink', n); }catch(e){} }
        try{ ffmpeg.FS('unlink','list.txt'); }catch(e){}
        try{ ffmpeg.FS('unlink','output.mp4'); }catch(e){}

      }catch(err){
        appendLog('Error during processing: ' + (err.message || err), true);
        ffStatusEl.textContent = 'error';
      }
    });

    function getExt(name){
      const m = name.match(/(\.[a-zA-Z0-9]+)$/);
      return m ? m[1] : '.mp4';
    }

    // small helper to catch unhandled rejections and show guidance
    window.addEventListener('unhandledrejection', (ev) => {
      appendLog('Unhandled rejection: ' + (ev.reason && ev.reason.message ? ev.reason.message : ev.reason), true);
    });

    // initial UI
    renderFiles();
    appendLog('Ready. Choose your shorts to combine.');
  </script>
</body>
</html>
