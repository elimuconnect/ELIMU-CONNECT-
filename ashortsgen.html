<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Elimu Connect • ShortsGen v3 (9:16 Canvas)</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<link href="https://fonts.googleapis.com/css2?family=Patrick+Hand&display=swap" rel="stylesheet">
<style>
  :root{
    --accent:#1976d2; --math:#ef6c00; --sci:#2e7d32; --eng:#0d47a1;
    --bubble-bg:#fff9e6; --subtitle-bg: rgba(10,25,90,0.85);
  }
  html,body{height:100%;margin:0;font-family:'Patrick Hand', ComicSans, Arial;background:linear-gradient(#e6f7ff,#ffffff);display:flex;justify-content:center;padding:12px}
  .app{width:420px;max-width:100%}
  header{display:flex;justify-content:space-between;align-items:center}
  h1{font-size:1rem;margin:0}
  .controls{display:flex;flex-wrap:wrap;gap:6px;margin:8px 0}
  select,input[type="file"],button{padding:8px;border-radius:8px;border:1px solid #ddd;font-weight:bold}
  button{background:var(--accent);color:white;border:none;cursor:pointer}
  .small{font-size:.8rem;color:#444}
  #stageWrap{width:360px;height:640px;margin:12px auto;border-radius:18px;overflow:hidden;box-shadow:0 14px 36px rgba(0,0,0,.2);position:relative;background:#222}
  /* Canvas fits inside stageWrap but actual pixels are 720x1280 (portrait) */
  #canvasPreview{width:100%;height:100%;display:block}
  .controls .row{display:flex;gap:6px}
  .status{font-size:.9rem;margin-top:8px}
  a.hidden{display:none}
  .hint{font-size:.8rem;color:#555;margin-top:6px}
</style>
</head>
<body>
  <div class="app">
    <header>
      <h1>Elimu Connect • ShortsGen v3</h1>
      <div class="small">9:16 Canvas • Cartoon bubble subtitles • Auto WebM</div>
    </header>

    <div class="controls">
      <label>Duration:
        <select id="duration"><option value="30">30s</option><option value="45">45s</option><option value="60" selected>60s</option></select>
      </label>

      <label>Voice method:
        <select id="voiceMethod">
          <option value="mic">Mic live (speak during recording)</option>
          <option value="upload">Upload voice file (embed)</option>
          <option value="tts">SpeechSynthesis preview (preview only)</option>
        </select>
      </label>

      <label>Voice gender:
        <select id="voiceGender"><option value="auto">Auto</option><option value="male">Male</option><option value="female">Female</option></select>
      </label>
    </div>

    <div class="controls row">
      <input type="file" id="voiceUpload" accept="audio/*" />
      <button id="useUploadBtn">Use Upload</button>
      <button id="genBtn">🎲 Generate Preview</button>
      <button id="recordBtn">🔴 Start & Record (auto-stop)</button>
    </div>

    <div id="stageWrap" title="This box is the recorded 9:16 area">
      <canvas id="canvasPreview" width="720" height="1280"></canvas>
    </div>

    <div class="controls">
      <a id="downloadLink" class="hidden"></a>
    </div>

    <div class="status" id="status">Click Generate Preview to unlock audio, then press Start & Record.</div>
    <div class="hint">Tip: if browser prompts to allow mic or screen, allow them. Best on desktop Chrome/Edge.</div>
  </div>

<script>
/* ---------- Configuration & assets ---------- */
const CANVAS_W = 720, CANVAS_H = 1280; // portrait 9:16
const BACKGROUNDS = [
  {name:'Sunny Schoolyard', url:'https://images.unsplash.com/photo-1528484701800-2b6e5b9f7f9c?auto=format&fit=crop&w=720&q=60'},
  {name:'Green Park', url:'https://images.unsplash.com/photo-1502082553048-f009c37129b9?auto=format&fit=crop&w=720&q=60'},
  {name:'Sky & Clouds', url:'https://images.unsplash.com/photo-1502082553048-5f26f4c8d3e0?auto=format&fit=crop&w=720&q=60'},
  {name:'Playground', url:'https://images.unsplash.com/photo-1507537297725-24a1c029d3ca?auto=format&fit=crop&w=720&q=60'},
  {name:'Chalkboard Classroom', url:'https://images.unsplash.com/photo-1515165562835-c15a6f7b1f88?auto=format&fit=crop&w=720&q=60'},
  {name:'Beach', url:'https://images.unsplash.com/photo-1507525428034-b723cf961d3e?auto=format&fit=crop&w=720&q=60'},
  {name:'Space (kids)', url:'https://images.unsplash.com/photo-1446776811953-b23d57bd21aa?auto=format&fit=crop&w=720&q=60'},
  {name:'Forest Glade', url:'https://images.unsplash.com/photo-1501785888041-af3ef285b470?auto=format&fit=crop&w=720&q=60'},
  {name:'Rainbow Hills', url:'https://images.unsplash.com/photo-1501785888041-9f8b9485fb55?auto=format&fit=crop&w=720&q=60'},
  {name:'Science Lab', url:'https://images.unsplash.com/photo-1581091012184-7c3a7b291a46?auto=format&fit=crop&w=720&q=60'}
];

const TOPICS = [
  {title:'Counting to 3', text:'One, two, three! Let’s count with apples.' , class:'math'},
  {title:'Why is the sky blue?', text:'The sky looks blue because sunlight scatters in the air.' , class:'science'},
  {title:'Simple addition', text:'One plus two equals three. Easy peasy!' , class:'math'},
  {title:'Capital letters', text:'A sentence starts with a capital letter.' , class:'english'},
  {title:'Trees help us', text:'Trees give oxygen and shade — be kind to trees!' , class:'science'},
  {title:'Funny riddle', text:'What has hands but cannot clap? A clock!' , class:'english'},
  {title:'Colors', text:'Red, blue and green — colors make the world fun!' , class:'english'},
  {title:'Square', text:'A square has four equal sides — can you draw one?' , class:'math'},
  {title:'Rainbows', text:'Water droplets bend light and create rainbows!' , class:'science'},
  {title:'Share a smile', text:'A smile can make someone’s day. Share one today!' , class:'english'}
];

const ANIMALS = {
  dogs:['https://cdn-icons-png.flaticon.com/512/194/194279.png','https://cdn-icons-png.flaticon.com/512/616/616408.png'],
  cats:['https://cdn-icons-png.flaticon.com/512/617/617498.png','https://cdn-icons-png.flaticon.com/512/1998/1998615.png']
};

/* ---------- Canvas & drawing ---------- */
const canvas = document.getElementById('canvasPreview');
const ctx = canvas.getContext('2d', { alpha: false }); // opaque for speed
const displayScale = 1; // we'll draw at native 720x1280

// keep animated elements state
let scene = {
  backgroundImg: null,
  bgName: '',
  cloud1: {x:-200, y:100, w:200, h:90, speed: 0.2},
  cloud2: {x:-350, y:200, w:250, h:110, speed: 0.12},
  animalA: {img:null, x:CANVAS_W*0.18, y:CANVAS_H-220, w:160, h:160, bounceTimer:0},
  animalB: {img:null, x:CANVAS_W*0.62, y:CANVAS_H-200, w:140, h:140, bounceTimer:0},
  bubble: {text:'Welcome!', x:CANVAS_W*0.5, y:120},
  subtitle: {text:'', x:CANVAS_W*0.5, y:CANVAS_H - 120}
};

/* ---------- UI elements ---------- */
const durationSel = document.getElementById('duration');
const voiceMethodSel = document.getElementById('voiceMethod');
const voiceGenderSel = document.getElementById('voiceGender');
const voiceUploadEl = document.getElementById('voiceUpload');
const useUploadBtn = document.getElementById('useUploadBtn');
const genBtn = document.getElementById('genBtn');
const recordBtn = document.getElementById('recordBtn');
const statusEl = document.getElementById('status');
const downloadLink = document.getElementById('downloadLink');

let currentTopic = null;
let uploadedAudioBuffer = null;

/* ---------- WebAudio: master mix ---------- */
const AudioContextClass = window.AudioContext || window.webkitAudioContext;
let audioCtx = null;
function ensureAudioCtx(){
  if(!audioCtx){
    audioCtx = new AudioContextClass();
    audioCtx.masterGain = audioCtx.createGain();
    audioCtx.masterGain.gain.value = 1;
    audioCtx.masterDest = audioCtx.createMediaStreamDestination();
    audioCtx.masterGain.connect(audioCtx.masterDest);
    audioCtx.masterGain.connect(audioCtx.destination);
  }
  return audioCtx;
}

// unlock audio on first gesture
function unlockAudioOnGesture(){
  const init = async ()=>{
    ensureAudioCtx();
    if(audioCtx.state === 'suspended') try{ await audioCtx.resume(); }catch(e){}
    document.body.removeEventListener('click', init);
    document.body.removeEventListener('keydown', init);
    statusEl.textContent = 'Audio unlocked — ready.';
  };
  document.body.addEventListener('click', init);
  document.body.addEventListener('keydown', init);
}
unlockAudioOnGesture();

/* ---------- Background music patterns (alternate) ---------- */
let bgPattern = null, bgPatternInterval = null, bgOscs = [];

function startBgPattern(idx){
  stopBgPattern();
  const ctx = ensureAudioCtx();
  // three simple patterns — arpeggio, plucky, playful rhythm
  if(idx === 0){
    // arpeggio pattern (light)
    const notes = [523.25, 659.25, 783.99, 1046.5];
    bgOscs = notes.map(n => {
      const o = ctx.createOscillator(); const g = ctx.createGain();
      o.type = 'sine'; o.frequency.value = n; g.gain.value = 0;
      o.connect(g); g.connect(ctx.masterGain); o.start();
      return {o,g};
    });
    bgPatternInterval = setInterval(()=>{
      const t = ctx.currentTime;
      bgOscs.forEach((og,i)=>{
        og.g.gain.cancelScheduledValues(t);
        og.g.gain.linearRampToValueAtTime(0.05, t+0.01);
        og.g.gain.linearRampToValueAtTime(0, t+0.45);
      });
    }, 520);
  } else if(idx === 1){
    // plucky marimba-like pattern
    const notes = [392, 523.25, 659.25, 784];
    bgOscs = notes.map(n => {
      const o = ctx.createOscillator(); const g = ctx.createGain();
      o.type = 'square'; o.frequency.value = n; g.gain.value = 0;
      o.connect(g); g.connect(ctx.masterGain); o.start();
      return {o,g};
    });
    bgPatternInterval = setInterval(()=>{
      const t = ctx.currentTime;
      bgOscs.forEach((og,i)=>{
        og.g.gain.cancelScheduledValues(t);
        og.g.gain.linearRampToValueAtTime(0.045, t+0.01);
        og.g.gain.linearRampToValueAtTime(0, t+0.5);
      });
    }, 480);
  } else {
    // playful rhythm (short pulses)
    bgOscs = [];
    bgPatternInterval = setInterval(()=>{
      const o = ctx.createOscillator(); const g = ctx.createGain();
      o.type = 'triangle'; o.frequency.value = 600;
      o.connect(g); g.connect(ctx.masterGain);
      const t = ctx.currentTime;
      g.gain.setValueAtTime(0, t);
      g.gain.linearRampToValueAtTime(0.12, t+0.01);
      g.gain.exponentialRampToValueAtTime(0.001, t+0.5);
      o.start(); o.stop(t+0.55);
    }, 700);
  }
  bgPattern = idx;
}
function stopBgPattern(){
  if(bgPatternInterval){ clearInterval(bgPatternInterval); bgPatternInterval = null; }
  if(bgOscs){ bgOscs.forEach(x=>{ try{x.o.stop()}catch(e){} }); bgOscs = []; }
}

/* ---------- SFX ---------- */
function playBoing(){
  const ctx = ensureAudioCtx(); const o = ctx.createOscillator(); const g = ctx.createGain();
  o.type = 'triangle'; o.frequency.value = 520; o.connect(g); g.connect(ctx.masterGain);
  const t = ctx.currentTime;
  g.gain.linearRampToValueAtTime(0.12, t+0.01); g.gain.exponentialRampToValueAtTime(0.001, t+0.6);
  o.start(); o.stop(t+0.8);
}
function playSparkle(){
  const ctx = ensureAudioCtx(); const o = ctx.createOscillator(); const g = ctx.createGain();
  o.type = 'sine'; o.frequency.value = 1200; o.connect(g); g.connect(ctx.masterGain);
  const t = ctx.currentTime;
  g.gain.linearRampToValueAtTime(0.08, t+0.01); g.gain.exponentialRampToValueAtTime(0.001, t+0.4);
  o.start(); o.stop(t+0.6);
}

/* ---------- Load images helper ---------- */
function loadImg(url){ return new Promise((res,rej)=>{ const i=new Image(); i.crossOrigin='anonymous'; i.onload=()=>res(i); i.onerror=rej; i.src=url; }); }

/* ---------- Randomize & prepare scene ---------- */
async function prepareScene(){
  // pick background
  const bg = BACKGROUNDS[Math.floor(Math.random()*BACKGROUNDS.length)];
  scene.bgName = bg.name;
  scene.backgroundImg = await loadImg(bg.url);
  // pick animals
  const dog = ANIMALS.dogs[Math.floor(Math.random()*ANIMALS.dogs.length)];
  const cat = ANIMALS.cats[Math.floor(Math.random()*ANIMALS.cats.length)];
  scene.animalA.img = await loadImg(dog);
  scene.animalB.img = await loadImg(cat);
  // pick topic
  currentTopic = TOPICS[Math.floor(Math.random()*TOPICS.length)];
  scene.bubble.text = currentTopic.title;
  scene.subtitle.text = currentTopic.text;
  // choose background music pattern random 0..2
  const bgIdx = Math.floor(Math.random()*3);
  startBgPattern(bgIdx);
  statusEl.textContent = `Prepared: ${scene.bgName} • ${currentTopic.title} • bg-music #${bgIdx+1}`;
}

/* ---------- Drawing functions ---------- */
function drawRoundRect(x,y,w,h,r, fill, stroke, lineWidth=2){
  ctx.beginPath();
  ctx.moveTo(x+r,y);
  ctx.arcTo(x+w,y,x+w,y+h,r);
  ctx.arcTo(x+w,y+h,x,y+h,r);
  ctx.arcTo(x,y+h,x,y,r);
  ctx.arcTo(x,y,x+w,y,r);
  ctx.closePath();
  if(fill){ ctx.fillStyle = fill; ctx.fill(); }
  if(stroke){ ctx.lineWidth = lineWidth; ctx.strokeStyle = stroke; ctx.stroke(); }
}
function drawScene(t){
  // clear
  ctx.clearRect(0,0,CANVAS_W,CANVAS_H);
  // background image (cover)
  if(scene.backgroundImg){
    ctx.drawImage(scene.backgroundImg, 0,0,CANVAS_W,CANVAS_H);
  } else {
    ctx.fillStyle = '#87ceeb'; ctx.fillRect(0,0,CANVAS_W,CANVAS_H);
  }

  // moving clouds (simple circles)
  // update cloud positions
  scene.cloud1.x += scene.cloud1.speed * (1 + Math.sin(t/200));
  scene.cloud2.x += scene.cloud2.speed * (1 + Math.cos(t/300));
  if(scene.cloud1.x > CANVAS_W + 200) scene.cloud1.x = -250;
  if(scene.cloud2.x > CANVAS_W + 250) scene.cloud2.x = -300;
  // draw them as soft white blobs
  function drawCloud(c){
    ctx.save(); ctx.fillStyle = 'rgba(255,255,255,0.95)';
    ctx.beginPath();
    ctx.ellipse(c.x, c.y, c.w*0.6, c.h*0.6, 0, 0, Math.PI*2);
    ctx.ellipse(c.x + c.w*0.4, c.y - 10, c.w*0.5, c.h*0.45, 0,0,Math.PI*2);
    ctx.ellipse(c.x + c.w*0.7, c.y + 6, c.w*0.35, c.h*0.33, 0,0,Math.PI*2);
    ctx.fill(); ctx.restore();
  }
  drawCloud(scene.cloud1); drawCloud(scene.cloud2);

  // draw animals (with bounce)
  function drawAnimal(a, tOffset){
    const bounce = Math.sin((t + (a.bounceTimer||0)) / 300) * 12; // -12..12
    const x = a.x; const y = a.y + bounce;
    ctx.save();
    // small shadow
    ctx.beginPath(); ctx.ellipse(x + a.w/2, y + a.h - 20, a.w*0.3, 12, 0, 0, Math.PI*2);
    ctx.fillStyle = 'rgba(0,0,0,0.12)'; ctx.fill();
    // draw image
    if(a.img) ctx.drawImage(a.img, x, y, a.w, a.h);
    ctx.restore();
  }
  // position animals relative to canvas width
  scene.animalA.x = CANVAS_W * 0.12;
  scene.animalB.x = CANVAS_W * 0.62;
  drawAnimal(scene.animalA, t);
  drawAnimal(scene.animalB, t);

  // bubble (cartoon bubble top)
  const bubbleW = Math.min( (scene.bubble.text.length*12) + 80, CANVAS_W*0.9);
  const bubbleH = 80;
  const bx = (CANVAS_W - bubbleW)/2;
  const by = 60;
  // draw speech bubble with tail
  drawRoundRect(bx, by, bubbleW, bubbleH, 32, 'rgba(255,249,230,0.98)', '#f0c987', 4);
  // tail
  ctx.beginPath(); ctx.moveTo(bx + bubbleW*0.6, by + bubbleH); ctx.lineTo(bx + bubbleW*0.6 + 18, by + bubbleH + 28); ctx.lineTo(bx + bubbleW*0.6 + 46, by + bubbleH - 6); ctx.closePath();
  ctx.fillStyle = 'rgba(255,249,230,0.98)'; ctx.fill(); ctx.strokeStyle = '#f0c987'; ctx.lineWidth=4; ctx.stroke();

  // bubble text
  ctx.fillStyle = '#1a237e'; ctx.font = 'bold 36px "Patrick Hand", ComicSans, Arial'; ctx.textAlign = 'center';
  wrapText(ctx, scene.bubble.text, CANVAS_W/2, by + bubbleH/2 + 8, bubbleW - 40, 36);

  // subtitle bubble bottom
  const subW = Math.min((scene.subtitle.text.length*10) + 80, CANVAS_W*0.95);
  const sbx = (CANVAS_W - subW)/2;
  const sby = CANVAS_H - 160;
  drawRoundRect(sbx, sby, subW, 90, 28, 'rgba(10,25,90,0.90)', null, 0);
  // subtitle text white, multiline
  ctx.fillStyle = '#fff'; ctx.font = '24px "Patrick Hand", ComicSans, Arial'; ctx.textAlign = 'center';
  wrapText(ctx, scene.subtitle.text, CANVAS_W/2, sby + 46, subW - 28, 28);

  // logo tag bottom-right
  ctx.fillStyle = 'rgba(255,255,255,0.95)';
  ctx.strokeStyle = 'rgba(0,0,0,0.08)';
  drawRoundRect(CANVAS_W - 150, CANVAS_H - 70, 130, 46, 18, 'rgba(255,255,255,0.95)', 'rgba(0,0,0,0.06)', 1);
  ctx.fillStyle = '#111'; ctx.font = '20px "Patrick Hand", Arial'; ctx.textAlign = 'center';
  ctx.fillText('Elimu Connect', CANVAS_W - 85, CANVAS_H - 42);
}

// text wrap helper
function wrapText(context, text, x, y, maxWidth, lineHeight){
  const words = text.split(' ');
  let line = '', testLine, metrics, testWidth;
  let curY = y - (lineHeight/2);
  for (let n = 0; n < words.length; n++) {
    testLine = line + words[n] + ' ';
    metrics = context.measureText(testLine);
    testWidth = metrics.width;
    if (testWidth > maxWidth && n > 0) {
      context.fillText(line, x, curY);
      line = words[n] + ' ';
      curY += lineHeight;
    } else {
      line = testLine;
    }
  }
  context.fillText(line, x, curY);
}

/* ---------- Animation loop ---------- */
let animRunning = false;
function startAnimation(){
  if(animRunning) return;
  animRunning = true;
  let start = performance.now();
  function loop(now){
    const t = now - start;
    // small dynamic updates
    scene.animalA.bounceTimer = t;
    scene.animalB.bounceTimer = t + 70;
    // draw
    drawScene(t);
    if(animRunning) requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);
}
function stopAnimation(){ animRunning = false; }

/* ---------- Prepare scene on Generate ---------- */
genBtn.addEventListener('click', async ()=>{
  statusEl.textContent = 'Preparing scene...';
  ensureAudioCtx();
  try{ await prepareScene(); startAnimation(); statusEl.textContent = 'Preview ready: ' + scene.bgName + ' • ' + currentTopic.title; }catch(e){ statusEl.textContent = 'Prepare failed: ' + e.message; console.error(e); }
});

/* ---------- Voice upload handling ---------- */
voiceUploadEl.addEventListener('change', async (e)=>{
  const f = e.target.files[0];
  if(!f) return;
  statusEl.textContent = 'Decoding uploaded audio...';
  const ab = await f.arrayBuffer();
  ensureAudioCtx();
  uploadedAudioBuffer = await audioCtx.decodeAudioData(ab);
  statusEl.textContent = 'Uploaded voice ready (will be embedded).';
});
useUploadBtn.addEventListener('click', ()=> {
  if(!uploadedAudioBuffer){ statusEl.textContent = 'No uploaded file. Choose an audio file first.'; return; }
  voiceMethodSel.value = 'upload';
  statusEl.textContent = 'Upload selected as narration method.';
});

/* ---------- SpeechSynthesis preview (not embedded) ---------- */
function speakPreview(text, gender){
  try{
    const voices = speechSynthesis.getVoices();
    let chosen = null;
    if(gender === 'male') chosen = voices.find(v => /male|en-GB|en-US/i.test(v.name)) || voices[0];
    else if(gender === 'female') chosen = voices.find(v => /female|en-GB|en-US/i.test(v.name)) || voices[0];
    else chosen = voices.find(v=>v.lang && v.lang.toLowerCase().includes('en')) || voices[0];
    const ut = new SpeechSynthesisUtterance(text);
    if(chosen) ut.voice = chosen;
    ut.rate = 0.95; ut.pitch = 1.05;
    speechSynthesis.cancel(); speechSynthesis.speak(ut);
  }catch(e){ console.warn('TTS preview error', e); }
}

/* ---------- Recording: capture only the canvas (canvas.captureStream) ---------- */
let recordedChunks = [];
let mediaRecorder = null;

async function startRecordingAuto(){
  // ensure audio unlocked
  ensureAudioCtx();
  if(audioCtx.state === 'suspended') try{ await audioCtx.resume(); }catch(e){}
  // must have a prepared scene
  if(!currentTopic){ statusEl.textContent = 'Generate preview first.'; return; }
  // start background music (already started in prepareScene) - ensure it is running
  if(!bgPattern) startBgPattern(Math.floor(Math.random()*3));

  const dur = parseInt(durationSel.value,10) || 60;
  statusEl.textContent = 'Recording: ' + dur + 's — preparing streams...';

  // canvas capture stream (video)
  let videoStream = null;
  try{
    // draw at desired frames per second
    videoStream = canvas.captureStream(30);
  }catch(err){
    statusEl.textContent = 'Canvas capture not supported: ' + err.message;
    return;
  }

  // assemble combined MediaStream
  const combined = new MediaStream();
  // add video tracks
  videoStream.getVideoTracks().forEach(t => combined.addTrack(t));

  // add live mic if chosen
  let liveMicStream = null;
  if(voiceMethodSel.value === 'mic'){
    try{
      liveMicStream = await navigator.mediaDevices.getUserMedia({ audio: true });
      liveMicStream.getAudioTracks().forEach(t => combined.addTrack(t));
      statusEl.textContent = 'Live mic connected — speak during recording.';
    }catch(err){
      statusEl.textContent = 'Mic unavailable. If you uploaded narration it will be used.';
      console.warn('Mic error', err);
    }
  }

  // if upload selected and uploadedAudioBuffer exists, schedule it to play into audioCtx.masterGain now
  if(voiceMethodSel.value === 'upload' && uploadedAudioBuffer){
    const src = audioCtx.createBufferSource();
    src.buffer = uploadedAudioBuffer;
    src.connect(audioCtx.masterGain);
    src.start();
    // also show subtitle parts timed across duration
  } else if(voiceMethodSel.value === 'tts'){
    // speechSynthesis preview (not embedded usually)
    speakPreview(currentTopic.title + '. ' + currentTopic.text, voiceGenderSel.value);
  }

  // include WebAudio masterDest tracks (bg music + sfx + uploaded buffer if played)
  audioCtx.masterDest.stream.getAudioTracks().forEach(t => combined.addTrack(t));

  recordedChunks = [];
  try{
    mediaRecorder = new MediaRecorder(combined, { mimeType: 'video/webm;codecs=vp8,opus' });
  }catch(err){
    statusEl.textContent = 'MediaRecorder failed: ' + err.message;
    return;
  }

  mediaRecorder.ondataavailable = e => { if(e.data && e.data.size) recordedChunks.push(e.data); };
  mediaRecorder.onstart = () => { statusEl.textContent = 'Recording... (auto stops after ' + dur + 's)'; };
  mediaRecorder.onerror = e => { statusEl.textContent = 'Recording error: ' + e.message; };
  mediaRecorder.onstop = async () => {
    // stop any live mic we opened
    if(liveMicStream) liveMicStream.getTracks().forEach(t=> t.stop());
    stopBgPattern();
    // assemble blob
    const blob = new Blob(recordedChunks, { type: 'video/webm' });
    const url = URL.createObjectURL(blob);
    downloadLink.href = url;
    downloadLink.download = `elimu_short_${dur}s_${Date.now()}.webm`;
    downloadLink.textContent = '⬇️ Download WebM (9:16)';
    downloadLink.classList.remove('hidden');
    // auto-trigger download (some browsers block but it tries)
    setTimeout(()=> { try{ downloadLink.click(); }catch(e){} }, 300);
    statusEl.textContent = 'Recording complete — file ready.';
  };

  // start recording
  mediaRecorder.start(1000);

  // schedule subtitles in 3 parts across duration
  const parts = splitText(currentTopic.text, 3);
  parts.forEach((p,i)=>{
    setTimeout(()=> { scene.subtitle.text = p; playBoing(); }, Math.floor((i+0.5)*(dur/parts.length)*1000));
  });

  // auto stop
  setTimeout(()=>{
    try{ if(mediaRecorder && mediaRecorder.state === 'recording') mediaRecorder.stop(); }catch(e){ console.warn('stop error', e); }
  }, dur*1000 + 500);
}

/* ---------- Helpers ---------- */
function splitText(text, n){
  const words = text.split(' ');
  const per = Math.ceil(words.length / n);
  const out = [];
  for(let i=0;i<n;i++) out.push(words.slice(i*per,(i+1)*per).join(' '));
  return out;
}

/* ---------- Events ---------- */
recordBtn.addEventListener('click', async ()=>{
  // user gesture unlocks audio & allows mic
  ensureAudioCtx();
  if(audioCtx.state === 'suspended') try{ await audioCtx.resume(); }catch(e){}
  // ensure scene prepared
  if(!currentTopic) await prepareScene();
  // small delay so music and visuals start
  setTimeout(()=> startRecordingAuto(), 250);
});

window.addEventListener('load', ()=> {
  // warm voices
  speechSynthesis.getVoices();
  // quick auto prepare
  generateOnLoad();
  statusEl.textContent = 'Ready. Click Generate Preview and then Start & Record.';
});

async function generateOnLoad(){
  try{ await prepareScene(); startAnimation(); }catch(e){}
}

</script>
</body>
</html>
